/*
 * generated by Xtext 2.12.0
 */
package ctwedge.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractEnumRuleElementFinder;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class CTWedgeGrammarAccess extends AbstractGrammarElementFinder {
	
	public class CitModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ctwedge.CTWedge.CitModel");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCitModelAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cModelKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cParametersKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cColonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cParametersAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cParametersParameterParserRuleCall_5_0 = (RuleCall)cParametersAssignment_5.eContents().get(0);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cConstraintsKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Keyword cColonKeyword_6_1 = (Keyword)cGroup_6.eContents().get(1);
		private final Assignment cConstraintsAssignment_6_2 = (Assignment)cGroup_6.eContents().get(2);
		private final RuleCall cConstraintsConstraintParserRuleCall_6_2_0 = (RuleCall)cConstraintsAssignment_6_2.eContents().get(0);
		
		//CitModel:
		//	{CitModel} 'Model' name=ID
		//	//list of parameters
		//	'Parameters' ':' parameters+=Parameter+ ('Constraints' ':' constraints+=Constraint+)?;
		@Override public ParserRule getRule() { return rule; }
		
		//{CitModel} 'Model' name=ID //list of parameters
		//'Parameters' ':' parameters+=Parameter+ ('Constraints' ':' constraints+=Constraint+)?
		public Group getGroup() { return cGroup; }
		
		//{CitModel}
		public Action getCitModelAction_0() { return cCitModelAction_0; }
		
		//'Model'
		public Keyword getModelKeyword_1() { return cModelKeyword_1; }
		
		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }
		
		////list of parameters
		//'Parameters'
		public Keyword getParametersKeyword_3() { return cParametersKeyword_3; }
		
		//':'
		public Keyword getColonKeyword_4() { return cColonKeyword_4; }
		
		//parameters+=Parameter+
		public Assignment getParametersAssignment_5() { return cParametersAssignment_5; }
		
		//Parameter
		public RuleCall getParametersParameterParserRuleCall_5_0() { return cParametersParameterParserRuleCall_5_0; }
		
		//('Constraints' ':' constraints+=Constraint+)?
		public Group getGroup_6() { return cGroup_6; }
		
		//'Constraints'
		public Keyword getConstraintsKeyword_6_0() { return cConstraintsKeyword_6_0; }
		
		//':'
		public Keyword getColonKeyword_6_1() { return cColonKeyword_6_1; }
		
		//constraints+=Constraint+
		public Assignment getConstraintsAssignment_6_2() { return cConstraintsAssignment_6_2; }
		
		//Constraint
		public RuleCall getConstraintsConstraintParserRuleCall_6_2_0() { return cConstraintsConstraintParserRuleCall_6_2_0; }
	}
	public class ParameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ctwedge.CTWedge.Parameter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cBoolParserRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final RuleCall cEnumerativeParserRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final RuleCall cRangeParserRuleCall_0_2 = (RuleCall)cAlternatives_0.eContents().get(2);
		private final Keyword cSemicolonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//Parameter:
		//	(Bool | Enumerative | Range) ';'?;
		@Override public ParserRule getRule() { return rule; }
		
		//(Bool | Enumerative | Range) ';'?
		public Group getGroup() { return cGroup; }
		
		//Bool | Enumerative | Range
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//Bool
		public RuleCall getBoolParserRuleCall_0_0() { return cBoolParserRuleCall_0_0; }
		
		//Enumerative
		public RuleCall getEnumerativeParserRuleCall_0_1() { return cEnumerativeParserRuleCall_0_1; }
		
		//Range
		public RuleCall getRangeParserRuleCall_0_2() { return cRangeParserRuleCall_0_2; }
		
		//';'?
		public Keyword getSemicolonKeyword_1() { return cSemicolonKeyword_1; }
	}
	public class BoolElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ctwedge.CTWedge.Bool");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cBooleanKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Bool:
		//	name=ID ':' 'Boolean';
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID ':' 'Boolean'
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//'Boolean'
		public Keyword getBooleanKeyword_2() { return cBooleanKeyword_2; }
	}
	public class EnumerativeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ctwedge.CTWedge.Enumerative");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cColonKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cElementsAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cElementsElementParserRuleCall_1_2_0 = (RuleCall)cElementsAssignment_1_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		//Enumerative:
		//	name=ID (':' '{' elements+=Element+ '}');
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID (':' '{' elements+=Element+ '}')
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//':' '{' elements+=Element+ '}'
		public Group getGroup_1() { return cGroup_1; }
		
		//':'
		public Keyword getColonKeyword_1_0() { return cColonKeyword_1_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1_1() { return cLeftCurlyBracketKeyword_1_1; }
		
		//elements+=Element+
		public Assignment getElementsAssignment_1_2() { return cElementsAssignment_1_2; }
		
		//Element
		public RuleCall getElementsElementParserRuleCall_1_2_0() { return cElementsElementParserRuleCall_1_2_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_1_3() { return cRightCurlyBracketKeyword_1_3; }
	}
	public class ElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ctwedge.CTWedge.Element");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameElementIDParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cCommaKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//// elements in the enumerative
		//Element:
		//	name=elementID ','?;
		@Override public ParserRule getRule() { return rule; }
		
		//name=elementID ','?
		public Group getGroup() { return cGroup; }
		
		//name=elementID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//elementID
		public RuleCall getNameElementIDParserRuleCall_0_0() { return cNameElementIDParserRuleCall_0_0; }
		
		//','?
		public Keyword getCommaKeyword_1() { return cCommaKeyword_1; }
	}
	public class RangeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ctwedge.CTWedge.Range");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cBeginAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cBeginPossiblySignedNumberParserRuleCall_3_0 = (RuleCall)cBeginAssignment_3.eContents().get(0);
		private final Keyword cFullStopFullStopKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cEndAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cEndPossiblySignedNumberParserRuleCall_5_0 = (RuleCall)cEndAssignment_5.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Group cGroup_7 = (Group)cGroup.eContents().get(7);
		private final Keyword cStepKeyword_7_0 = (Keyword)cGroup_7.eContents().get(0);
		private final Assignment cStepAssignment_7_1 = (Assignment)cGroup_7.eContents().get(1);
		private final RuleCall cStepINTTerminalRuleCall_7_1_0 = (RuleCall)cStepAssignment_7_1.eContents().get(0);
		
		//Range:
		//	name=ID ':' '[' begin=PossiblySignedNumber '..' end=PossiblySignedNumber ']' ('step' step=INT)?;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID ':' '[' begin=PossiblySignedNumber '..' end=PossiblySignedNumber ']' ('step' step=INT)?
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_2() { return cLeftSquareBracketKeyword_2; }
		
		//begin=PossiblySignedNumber
		public Assignment getBeginAssignment_3() { return cBeginAssignment_3; }
		
		//PossiblySignedNumber
		public RuleCall getBeginPossiblySignedNumberParserRuleCall_3_0() { return cBeginPossiblySignedNumberParserRuleCall_3_0; }
		
		//'..'
		public Keyword getFullStopFullStopKeyword_4() { return cFullStopFullStopKeyword_4; }
		
		//end=PossiblySignedNumber
		public Assignment getEndAssignment_5() { return cEndAssignment_5; }
		
		//PossiblySignedNumber
		public RuleCall getEndPossiblySignedNumberParserRuleCall_5_0() { return cEndPossiblySignedNumberParserRuleCall_5_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_6() { return cRightSquareBracketKeyword_6; }
		
		//('step' step=INT)?
		public Group getGroup_7() { return cGroup_7; }
		
		//'step'
		public Keyword getStepKeyword_7_0() { return cStepKeyword_7_0; }
		
		//step=INT
		public Assignment getStepAssignment_7_1() { return cStepAssignment_7_1; }
		
		//INT
		public RuleCall getStepINTTerminalRuleCall_7_1_0() { return cStepINTTerminalRuleCall_7_1_0; }
	}
	public class ConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ctwedge.CTWedge.Constraint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNumberSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cImpliesExpressionParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cNumberSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		////range of value of a constant
		//// CONSTRAINTS
		//// expressions defined in top down way starting from less precedence	
		//Constraint:
		//	'#' ImpliesExpression '#';
		@Override public ParserRule getRule() { return rule; }
		
		//'#' ImpliesExpression '#'
		public Group getGroup() { return cGroup; }
		
		//'#'
		public Keyword getNumberSignKeyword_0() { return cNumberSignKeyword_0; }
		
		//ImpliesExpression
		public RuleCall getImpliesExpressionParserRuleCall_1() { return cImpliesExpressionParserRuleCall_1; }
		
		//'#'
		public Keyword getNumberSignKeyword_2() { return cNumberSignKeyword_2; }
	}
	public class ImpliesExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ctwedge.CTWedge.ImpliesExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOrExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cImpliesExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpImpliesOperatorEnumRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOrExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//// precedence:
		//// not, and, or, implies
		//ImpliesExpression Expression:
		//	OrExpression ({ImpliesExpression.left=current} op=ImpliesOperator right=OrExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//OrExpression ({ImpliesExpression.left=current} op=ImpliesOperator right=OrExpression)*
		public Group getGroup() { return cGroup; }
		
		//OrExpression
		public RuleCall getOrExpressionParserRuleCall_0() { return cOrExpressionParserRuleCall_0; }
		
		//({ImpliesExpression.left=current} op=ImpliesOperator right=OrExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{ImpliesExpression.left=current}
		public Action getImpliesExpressionLeftAction_1_0() { return cImpliesExpressionLeftAction_1_0; }
		
		//op=ImpliesOperator
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//ImpliesOperator
		public RuleCall getOpImpliesOperatorEnumRuleCall_1_1_0() { return cOpImpliesOperatorEnumRuleCall_1_1_0; }
		
		//right=OrExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//OrExpression
		public RuleCall getRightOrExpressionParserRuleCall_1_2_0() { return cRightOrExpressionParserRuleCall_1_2_0; }
	}
	public class OrExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ctwedge.CTWedge.OrExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOrExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final RuleCall cOR_OPERATORParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAndExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//// 
		//OrExpression Expression:
		//	AndExpression ({OrExpression.left=current} OR_OPERATOR right=AndExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//AndExpression ({OrExpression.left=current} OR_OPERATOR right=AndExpression)*
		public Group getGroup() { return cGroup; }
		
		//AndExpression
		public RuleCall getAndExpressionParserRuleCall_0() { return cAndExpressionParserRuleCall_0; }
		
		//({OrExpression.left=current} OR_OPERATOR right=AndExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{OrExpression.left=current}
		public Action getOrExpressionLeftAction_1_0() { return cOrExpressionLeftAction_1_0; }
		
		//OR_OPERATOR
		public RuleCall getOR_OPERATORParserRuleCall_1_1() { return cOR_OPERATORParserRuleCall_1_1; }
		
		//right=AndExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//AndExpression
		public RuleCall getRightAndExpressionParserRuleCall_1_2_0() { return cRightAndExpressionParserRuleCall_1_2_0; }
	}
	public class AndExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ctwedge.CTWedge.AndExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cEqualExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final RuleCall cAND_OPERATORParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightEqualExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//AndExpression Expression:
		//	EqualExpression ({AndExpression.left=current} AND_OPERATOR right=EqualExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//EqualExpression ({AndExpression.left=current} AND_OPERATOR right=EqualExpression)*
		public Group getGroup() { return cGroup; }
		
		//EqualExpression
		public RuleCall getEqualExpressionParserRuleCall_0() { return cEqualExpressionParserRuleCall_0; }
		
		//({AndExpression.left=current} AND_OPERATOR right=EqualExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{AndExpression.left=current}
		public Action getAndExpressionLeftAction_1_0() { return cAndExpressionLeftAction_1_0; }
		
		//AND_OPERATOR
		public RuleCall getAND_OPERATORParserRuleCall_1_1() { return cAND_OPERATORParserRuleCall_1_1; }
		
		//right=EqualExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//EqualExpression
		public RuleCall getRightEqualExpressionParserRuleCall_1_2_0() { return cRightEqualExpressionParserRuleCall_1_2_0; }
	}
	public class EqualExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ctwedge.CTWedge.EqualExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cRelationalExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cEqualExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpEqualityOperatorsEnumRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightRelationalExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//EqualExpression Expression:
		//	RelationalExpression ({EqualExpression.left=current} op=EqualityOperators right=RelationalExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//RelationalExpression ({EqualExpression.left=current} op=EqualityOperators right=RelationalExpression)*
		public Group getGroup() { return cGroup; }
		
		//RelationalExpression
		public RuleCall getRelationalExpressionParserRuleCall_0() { return cRelationalExpressionParserRuleCall_0; }
		
		//({EqualExpression.left=current} op=EqualityOperators right=RelationalExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{EqualExpression.left=current}
		public Action getEqualExpressionLeftAction_1_0() { return cEqualExpressionLeftAction_1_0; }
		
		//op=EqualityOperators
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//EqualityOperators
		public RuleCall getOpEqualityOperatorsEnumRuleCall_1_1_0() { return cOpEqualityOperatorsEnumRuleCall_1_1_0; }
		
		//right=RelationalExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//RelationalExpression
		public RuleCall getRightRelationalExpressionParserRuleCall_1_2_0() { return cRightRelationalExpressionParserRuleCall_1_2_0; }
	}
	public class RelationalExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ctwedge.CTWedge.RelationalExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPlusMinusParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cRelationalExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpRelationalOperatorsEnumRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPlusMinusParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//RelationalExpression Expression:
		//	PlusMinus ({RelationalExpression.left=current} op=RelationalOperators right=PlusMinus)*;
		@Override public ParserRule getRule() { return rule; }
		
		//PlusMinus ({RelationalExpression.left=current} op=RelationalOperators right=PlusMinus)*
		public Group getGroup() { return cGroup; }
		
		//PlusMinus
		public RuleCall getPlusMinusParserRuleCall_0() { return cPlusMinusParserRuleCall_0; }
		
		//({RelationalExpression.left=current} op=RelationalOperators right=PlusMinus)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{RelationalExpression.left=current}
		public Action getRelationalExpressionLeftAction_1_0() { return cRelationalExpressionLeftAction_1_0; }
		
		//op=RelationalOperators
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//RelationalOperators
		public RuleCall getOpRelationalOperatorsEnumRuleCall_1_1_0() { return cOpRelationalOperatorsEnumRuleCall_1_1_0; }
		
		//right=PlusMinus
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//PlusMinus
		public RuleCall getRightPlusMinusParserRuleCall_1_2_0() { return cRightPlusMinusParserRuleCall_1_2_0; }
	}
	public class PlusMinusElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ctwedge.CTWedge.PlusMinus");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cModMultDivParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cPlusMinusLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpPlusMinusOperatorsEnumRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightModMultDivParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//// a<b<c? 
		//// numerical expressions
		//PlusMinus Expression:
		//	ModMultDiv ({PlusMinus.left=current} op=PlusMinusOperators right=ModMultDiv)*;
		@Override public ParserRule getRule() { return rule; }
		
		//ModMultDiv ({PlusMinus.left=current} op=PlusMinusOperators right=ModMultDiv)*
		public Group getGroup() { return cGroup; }
		
		//ModMultDiv
		public RuleCall getModMultDivParserRuleCall_0() { return cModMultDivParserRuleCall_0; }
		
		//({PlusMinus.left=current} op=PlusMinusOperators right=ModMultDiv)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{PlusMinus.left=current}
		public Action getPlusMinusLeftAction_1_0() { return cPlusMinusLeftAction_1_0; }
		
		//op=PlusMinusOperators
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//PlusMinusOperators
		public RuleCall getOpPlusMinusOperatorsEnumRuleCall_1_1_0() { return cOpPlusMinusOperatorsEnumRuleCall_1_1_0; }
		
		//right=ModMultDiv
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//ModMultDiv
		public RuleCall getRightModMultDivParserRuleCall_1_2_0() { return cRightModMultDivParserRuleCall_1_2_0; }
	}
	public class ModMultDivElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ctwedge.CTWedge.ModMultDiv");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cModMultDivLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpModMultDivOperatorsEnumRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPrimaryParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//ModMultDiv Expression:
		//	Primary ({ModMultDiv.left=current} op=ModMultDivOperators right=Primary)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Primary ({ModMultDiv.left=current} op=ModMultDivOperators right=Primary)*
		public Group getGroup() { return cGroup; }
		
		//Primary
		public RuleCall getPrimaryParserRuleCall_0() { return cPrimaryParserRuleCall_0; }
		
		//({ModMultDiv.left=current} op=ModMultDivOperators right=Primary)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{ModMultDiv.left=current}
		public Action getModMultDivLeftAction_1_0() { return cModMultDivLeftAction_1_0; }
		
		//op=ModMultDivOperators
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//ModMultDivOperators
		public RuleCall getOpModMultDivOperatorsEnumRuleCall_1_1_0() { return cOpModMultDivOperatorsEnumRuleCall_1_1_0; }
		
		//right=Primary
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Primary
		public RuleCall getRightPrimaryParserRuleCall_1_2_0() { return cRightPrimaryParserRuleCall_1_2_0; }
	}
	public class PrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ctwedge.CTWedge.Primary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNotExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cImpliesExpressionParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final RuleCall cAtomicPredicateParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Primary Expression:
		//	NotExpression | '(' ImpliesExpression ')' | AtomicPredicate;
		@Override public ParserRule getRule() { return rule; }
		
		//NotExpression | '(' ImpliesExpression ')' | AtomicPredicate
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//NotExpression
		public RuleCall getNotExpressionParserRuleCall_0() { return cNotExpressionParserRuleCall_0; }
		
		//'(' ImpliesExpression ')'
		public Group getGroup_1() { return cGroup_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }
		
		//ImpliesExpression
		public RuleCall getImpliesExpressionParserRuleCall_1_1() { return cImpliesExpressionParserRuleCall_1_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
		
		//AtomicPredicate
		public RuleCall getAtomicPredicateParserRuleCall_2() { return cAtomicPredicateParserRuleCall_2; }
	}
	public class NotExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ctwedge.CTWedge.NotExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cNOT_OPERATORParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final RuleCall cPrimaryParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Action cNotExpressionPredicateAction_2 = (Action)cGroup.eContents().get(2);
		
		//NotExpression Expression:
		//	NOT_OPERATOR Primary {NotExpression.predicate=current};
		@Override public ParserRule getRule() { return rule; }
		
		////to add + - unary
		//NOT_OPERATOR Primary {NotExpression.predicate=current}
		public Group getGroup() { return cGroup; }
		
		////to add + - unary
		//NOT_OPERATOR
		public RuleCall getNOT_OPERATORParserRuleCall_0() { return cNOT_OPERATORParserRuleCall_0; }
		
		//Primary
		public RuleCall getPrimaryParserRuleCall_1() { return cPrimaryParserRuleCall_1; }
		
		//{NotExpression.predicate=current}
		public Action getNotExpressionPredicateAction_2() { return cNotExpressionPredicateAction_2; }
	}
	public class AtomicPredicateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ctwedge.CTWedge.AtomicPredicate");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cBoolConstAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cBoolConstBoolConstParserRuleCall_0_0 = (RuleCall)cBoolConstAssignment_0.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cNameElementIDParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//// return an atomic predicate that cannot be further decomposed in predicates
		//AtomicPredicate:
		//	boolConst=BoolConst | name=elementID;
		@Override public ParserRule getRule() { return rule; }
		
		////v=[BoolTerm] | v=[Enumerative] | v=[RelationalExpression] | v=[Element] |
		//boolConst=BoolConst | name=elementID
		public Alternatives getAlternatives() { return cAlternatives; }
		
		////v=[BoolTerm] | v=[Enumerative] | v=[RelationalExpression] | v=[Element] |
		//boolConst=BoolConst
		public Assignment getBoolConstAssignment_0() { return cBoolConstAssignment_0; }
		
		//BoolConst
		public RuleCall getBoolConstBoolConstParserRuleCall_0_0() { return cBoolConstBoolConstParserRuleCall_0_0; }
		
		//name=elementID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//elementID
		public RuleCall getNameElementIDParserRuleCall_1_0() { return cNameElementIDParserRuleCall_1_0; }
	}
	public class OR_OPERATORElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ctwedge.CTWedge.OR_OPERATOR");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cVerticalLineVerticalLineKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cOrKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cORKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cVerticalLineKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		
		//// it gives a warning, but it works
		///*enum AndOperators:
		//	and='&&' | andmi='and' | ANDma='AND';
		//enum OrOperators:
		//	or='||' | ormi='or' | ORma='OR'; */ OR_OPERATOR:
		//	'||' | 'or' | 'OR' | '|';
		@Override public ParserRule getRule() { return rule; }
		
		//'||' | 'or' | 'OR' | '|'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'||'
		public Keyword getVerticalLineVerticalLineKeyword_0() { return cVerticalLineVerticalLineKeyword_0; }
		
		//'or'
		public Keyword getOrKeyword_1() { return cOrKeyword_1; }
		
		//'OR'
		public Keyword getORKeyword_2() { return cORKeyword_2; }
		
		//'|'
		public Keyword getVerticalLineKeyword_3() { return cVerticalLineKeyword_3; }
	}
	public class AND_OPERATORElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ctwedge.CTWedge.AND_OPERATOR");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cAmpersandAmpersandKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cAndKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cANDKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cAmpersandKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		
		//AND_OPERATOR:
		//	'&&' | 'and' | 'AND' | '&';
		@Override public ParserRule getRule() { return rule; }
		
		//'&&' | 'and' | 'AND' | '&'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'&&'
		public Keyword getAmpersandAmpersandKeyword_0() { return cAmpersandAmpersandKeyword_0; }
		
		//'and'
		public Keyword getAndKeyword_1() { return cAndKeyword_1; }
		
		//'AND'
		public Keyword getANDKeyword_2() { return cANDKeyword_2; }
		
		//'&'
		public Keyword getAmpersandKeyword_3() { return cAmpersandKeyword_3; }
	}
	public class NOT_OPERATORElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ctwedge.CTWedge.NOT_OPERATOR");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cExclamationMarkKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cNotKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//NOT_OPERATOR:
		//	'!' | 'not';
		@Override public ParserRule getRule() { return rule; }
		
		//'!' | 'not'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'!'
		public Keyword getExclamationMarkKeyword_0() { return cExclamationMarkKeyword_0; }
		
		//'not'
		public Keyword getNotKeyword_1() { return cNotKeyword_1; }
	}
	public class BoolConstElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ctwedge.CTWedge.BoolConst");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cFalseKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cTrueKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cFALSEKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cTRUEKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		
		//// it gives a warning, but it works
		//BoolConst:
		//	'false' | 'true' | 'FALSE' | 'TRUE';
		@Override public ParserRule getRule() { return rule; }
		
		//'false' | 'true' | 'FALSE' | 'TRUE'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'false'
		public Keyword getFalseKeyword_0() { return cFalseKeyword_0; }
		
		//'true'
		public Keyword getTrueKeyword_1() { return cTrueKeyword_1; }
		
		//'FALSE'
		public Keyword getFALSEKeyword_2() { return cFALSEKeyword_2; }
		
		//'TRUE'
		public Keyword getTRUEKeyword_3() { return cTRUEKeyword_3; }
	}
	public class ElementIDElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ctwedge.CTWedge.elementID");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cNUMIDTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Keyword cHyphenMinusKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_3_1 = (RuleCall)cGroup_3.eContents().get(1);
		
		//elementID:
		//	ID | NUMID | STRING | '-'? INT;
		@Override public ParserRule getRule() { return rule; }
		
		//ID | NUMID | STRING | '-'? INT
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }
		
		//NUMID
		public RuleCall getNUMIDTerminalRuleCall_1() { return cNUMIDTerminalRuleCall_1; }
		
		//STRING
		public RuleCall getSTRINGTerminalRuleCall_2() { return cSTRINGTerminalRuleCall_2; }
		
		//'-'? INT
		public Group getGroup_3() { return cGroup_3; }
		
		//'-'?
		public Keyword getHyphenMinusKeyword_3_0() { return cHyphenMinusKeyword_3_0; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_3_1() { return cINTTerminalRuleCall_3_1; }
	}
	public class PossiblySignedNumberElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ctwedge.CTWedge.PossiblySignedNumber");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//PossiblySignedNumber EIntegerObject:
		//	'-'? INT;
		@Override public ParserRule getRule() { return rule; }
		
		//'-'? INT
		public Group getGroup() { return cGroup; }
		
		//'-'?
		public Keyword getHyphenMinusKeyword_0() { return cHyphenMinusKeyword_0; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_1() { return cINTTerminalRuleCall_1; }
	}
	
	public class RelationalOperatorsElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ctwedge.CTWedge.RelationalOperators");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cGTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cGTGreaterThanSignKeyword_0_0 = (Keyword)cGTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cLTEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cLTLessThanSignKeyword_1_0 = (Keyword)cLTEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cGEEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cGEGreaterThanSignEqualsSignKeyword_2_0 = (Keyword)cGEEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cLEEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cLELessThanSignEqualsSignKeyword_3_0 = (Keyword)cLEEnumLiteralDeclaration_3.eContents().get(0);
		
		//enum RelationalOperators returns Operators:
		//	GT='>' | LT='<' | GE='>=' | LE='<=';
		public EnumRule getRule() { return rule; }
		
		//GT='>' | LT='<' | GE='>=' | LE='<='
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//GT='>'
		public EnumLiteralDeclaration getGTEnumLiteralDeclaration_0() { return cGTEnumLiteralDeclaration_0; }
		
		//'>'
		public Keyword getGTGreaterThanSignKeyword_0_0() { return cGTGreaterThanSignKeyword_0_0; }
		
		//LT='<'
		public EnumLiteralDeclaration getLTEnumLiteralDeclaration_1() { return cLTEnumLiteralDeclaration_1; }
		
		//'<'
		public Keyword getLTLessThanSignKeyword_1_0() { return cLTLessThanSignKeyword_1_0; }
		
		//GE='>='
		public EnumLiteralDeclaration getGEEnumLiteralDeclaration_2() { return cGEEnumLiteralDeclaration_2; }
		
		//'>='
		public Keyword getGEGreaterThanSignEqualsSignKeyword_2_0() { return cGEGreaterThanSignEqualsSignKeyword_2_0; }
		
		//LE='<='
		public EnumLiteralDeclaration getLEEnumLiteralDeclaration_3() { return cLEEnumLiteralDeclaration_3; }
		
		//'<='
		public Keyword getLELessThanSignEqualsSignKeyword_3_0() { return cLELessThanSignEqualsSignKeyword_3_0; }
	}
	public class EqualityOperatorsElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ctwedge.CTWedge.EqualityOperators");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cEQEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cEQEqualsSignEqualsSignKeyword_0_0 = (Keyword)cEQEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cNEEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cNEExclamationMarkEqualsSignKeyword_1_0 = (Keyword)cNEEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cEQEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cEQEqualsSignKeyword_2_0 = (Keyword)cEQEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum EqualityOperators returns Operators:
		//	EQ='==' | NE='!='
		//	| EQ='=';
		public EnumRule getRule() { return rule; }
		
		//EQ='==' | NE='!=' | EQ='='
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//EQ='=='
		public EnumLiteralDeclaration getEQEnumLiteralDeclaration_0() { return cEQEnumLiteralDeclaration_0; }
		
		//'=='
		public Keyword getEQEqualsSignEqualsSignKeyword_0_0() { return cEQEqualsSignEqualsSignKeyword_0_0; }
		
		//NE='!='
		public EnumLiteralDeclaration getNEEnumLiteralDeclaration_1() { return cNEEnumLiteralDeclaration_1; }
		
		//'!='
		public Keyword getNEExclamationMarkEqualsSignKeyword_1_0() { return cNEExclamationMarkEqualsSignKeyword_1_0; }
		
		//EQ='='
		public EnumLiteralDeclaration getEQEnumLiteralDeclaration_2() { return cEQEnumLiteralDeclaration_2; }
		
		//'='
		public Keyword getEQEqualsSignKeyword_2_0() { return cEQEqualsSignKeyword_2_0; }
	}
	public class PlusMinusOperatorsElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ctwedge.CTWedge.PlusMinusOperators");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cPlusEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cPlusPlusSignKeyword_0_0 = (Keyword)cPlusEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMinusEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMinusHyphenMinusKeyword_1_0 = (Keyword)cMinusEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum PlusMinusOperators:
		//	Plus='+' | Minus='-';
		public EnumRule getRule() { return rule; }
		
		//Plus='+' | Minus='-'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Plus='+'
		public EnumLiteralDeclaration getPlusEnumLiteralDeclaration_0() { return cPlusEnumLiteralDeclaration_0; }
		
		//'+'
		public Keyword getPlusPlusSignKeyword_0_0() { return cPlusPlusSignKeyword_0_0; }
		
		//Minus='-'
		public EnumLiteralDeclaration getMinusEnumLiteralDeclaration_1() { return cMinusEnumLiteralDeclaration_1; }
		
		//'-'
		public Keyword getMinusHyphenMinusKeyword_1_0() { return cMinusHyphenMinusKeyword_1_0; }
	}
	public class ModMultDivOperatorsElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ctwedge.CTWedge.ModMultDivOperators");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cModEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cModPercentSignKeyword_0_0 = (Keyword)cModEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMultEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMultAsteriskKeyword_1_0 = (Keyword)cMultEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cDivEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cDivSolidusKeyword_2_0 = (Keyword)cDivEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum ModMultDivOperators:
		//	Mod='%' | Mult='*' | Div='/';
		public EnumRule getRule() { return rule; }
		
		//Mod='%' | Mult='*' | Div='/'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Mod='%'
		public EnumLiteralDeclaration getModEnumLiteralDeclaration_0() { return cModEnumLiteralDeclaration_0; }
		
		//'%'
		public Keyword getModPercentSignKeyword_0_0() { return cModPercentSignKeyword_0_0; }
		
		//Mult='*'
		public EnumLiteralDeclaration getMultEnumLiteralDeclaration_1() { return cMultEnumLiteralDeclaration_1; }
		
		//'*'
		public Keyword getMultAsteriskKeyword_1_0() { return cMultAsteriskKeyword_1_0; }
		
		//Div='/'
		public EnumLiteralDeclaration getDivEnumLiteralDeclaration_2() { return cDivEnumLiteralDeclaration_2; }
		
		//'/'
		public Keyword getDivSolidusKeyword_2_0() { return cDivSolidusKeyword_2_0; }
	}
	public class ImpliesOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ctwedge.CTWedge.ImpliesOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cImplEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cImplEqualsSignGreaterThanSignKeyword_0_0 = (Keyword)cImplEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cIffEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cIffLessThanSignEqualsSignGreaterThanSignKeyword_1_0 = (Keyword)cIffEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cImplEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cImplHyphenMinusGreaterThanSignKeyword_2_0 = (Keyword)cImplEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cIffEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cIffLessThanSignHyphenMinusGreaterThanSignKeyword_3_0 = (Keyword)cIffEnumLiteralDeclaration_3.eContents().get(0);
		
		//enum ImpliesOperator:
		//	Impl='=>' | Iff='<=>' |
		//	Impl='->' | Iff='<->';
		public EnumRule getRule() { return rule; }
		
		//Impl='=>' | Iff='<=>' | Impl='->' | Iff='<->'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Impl='=>'
		public EnumLiteralDeclaration getImplEnumLiteralDeclaration_0() { return cImplEnumLiteralDeclaration_0; }
		
		//'=>'
		public Keyword getImplEqualsSignGreaterThanSignKeyword_0_0() { return cImplEqualsSignGreaterThanSignKeyword_0_0; }
		
		//Iff='<=>'
		public EnumLiteralDeclaration getIffEnumLiteralDeclaration_1() { return cIffEnumLiteralDeclaration_1; }
		
		//'<=>'
		public Keyword getIffLessThanSignEqualsSignGreaterThanSignKeyword_1_0() { return cIffLessThanSignEqualsSignGreaterThanSignKeyword_1_0; }
		
		//Impl='->'
		public EnumLiteralDeclaration getImplEnumLiteralDeclaration_2() { return cImplEnumLiteralDeclaration_2; }
		
		//'->'
		public Keyword getImplHyphenMinusGreaterThanSignKeyword_2_0() { return cImplHyphenMinusGreaterThanSignKeyword_2_0; }
		
		//Iff='<->'
		public EnumLiteralDeclaration getIffEnumLiteralDeclaration_3() { return cIffEnumLiteralDeclaration_3; }
		
		//'<->'
		public Keyword getIffLessThanSignHyphenMinusGreaterThanSignKeyword_3_0() { return cIffLessThanSignHyphenMinusGreaterThanSignKeyword_3_0; }
	}
	
	private final CitModelElements pCitModel;
	private final ParameterElements pParameter;
	private final BoolElements pBool;
	private final EnumerativeElements pEnumerative;
	private final ElementElements pElement;
	private final RangeElements pRange;
	private final ConstraintElements pConstraint;
	private final ImpliesExpressionElements pImpliesExpression;
	private final OrExpressionElements pOrExpression;
	private final AndExpressionElements pAndExpression;
	private final EqualExpressionElements pEqualExpression;
	private final RelationalExpressionElements pRelationalExpression;
	private final PlusMinusElements pPlusMinus;
	private final ModMultDivElements pModMultDiv;
	private final PrimaryElements pPrimary;
	private final NotExpressionElements pNotExpression;
	private final AtomicPredicateElements pAtomicPredicate;
	private final RelationalOperatorsElements eRelationalOperators;
	private final EqualityOperatorsElements eEqualityOperators;
	private final OR_OPERATORElements pOR_OPERATOR;
	private final AND_OPERATORElements pAND_OPERATOR;
	private final NOT_OPERATORElements pNOT_OPERATOR;
	private final PlusMinusOperatorsElements ePlusMinusOperators;
	private final ModMultDivOperatorsElements eModMultDivOperators;
	private final ImpliesOperatorElements eImpliesOperator;
	private final BoolConstElements pBoolConst;
	private final ElementIDElements pElementID;
	private final TerminalRule tNUMID;
	private final PossiblySignedNumberElements pPossiblySignedNumber;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public CTWedgeGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pCitModel = new CitModelElements();
		this.pParameter = new ParameterElements();
		this.pBool = new BoolElements();
		this.pEnumerative = new EnumerativeElements();
		this.pElement = new ElementElements();
		this.pRange = new RangeElements();
		this.pConstraint = new ConstraintElements();
		this.pImpliesExpression = new ImpliesExpressionElements();
		this.pOrExpression = new OrExpressionElements();
		this.pAndExpression = new AndExpressionElements();
		this.pEqualExpression = new EqualExpressionElements();
		this.pRelationalExpression = new RelationalExpressionElements();
		this.pPlusMinus = new PlusMinusElements();
		this.pModMultDiv = new ModMultDivElements();
		this.pPrimary = new PrimaryElements();
		this.pNotExpression = new NotExpressionElements();
		this.pAtomicPredicate = new AtomicPredicateElements();
		this.eRelationalOperators = new RelationalOperatorsElements();
		this.eEqualityOperators = new EqualityOperatorsElements();
		this.pOR_OPERATOR = new OR_OPERATORElements();
		this.pAND_OPERATOR = new AND_OPERATORElements();
		this.pNOT_OPERATOR = new NOT_OPERATORElements();
		this.ePlusMinusOperators = new PlusMinusOperatorsElements();
		this.eModMultDivOperators = new ModMultDivOperatorsElements();
		this.eImpliesOperator = new ImpliesOperatorElements();
		this.pBoolConst = new BoolConstElements();
		this.pElementID = new ElementIDElements();
		this.tNUMID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ctwedge.CTWedge.NUMID");
		this.pPossiblySignedNumber = new PossiblySignedNumberElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("ctwedge.CTWedge".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//CitModel:
	//	{CitModel} 'Model' name=ID
	//	//list of parameters
	//	'Parameters' ':' parameters+=Parameter+ ('Constraints' ':' constraints+=Constraint+)?;
	public CitModelElements getCitModelAccess() {
		return pCitModel;
	}
	
	public ParserRule getCitModelRule() {
		return getCitModelAccess().getRule();
	}
	
	//Parameter:
	//	(Bool | Enumerative | Range) ';'?;
	public ParameterElements getParameterAccess() {
		return pParameter;
	}
	
	public ParserRule getParameterRule() {
		return getParameterAccess().getRule();
	}
	
	//Bool:
	//	name=ID ':' 'Boolean';
	public BoolElements getBoolAccess() {
		return pBool;
	}
	
	public ParserRule getBoolRule() {
		return getBoolAccess().getRule();
	}
	
	//Enumerative:
	//	name=ID (':' '{' elements+=Element+ '}');
	public EnumerativeElements getEnumerativeAccess() {
		return pEnumerative;
	}
	
	public ParserRule getEnumerativeRule() {
		return getEnumerativeAccess().getRule();
	}
	
	//// elements in the enumerative
	//Element:
	//	name=elementID ','?;
	public ElementElements getElementAccess() {
		return pElement;
	}
	
	public ParserRule getElementRule() {
		return getElementAccess().getRule();
	}
	
	//Range:
	//	name=ID ':' '[' begin=PossiblySignedNumber '..' end=PossiblySignedNumber ']' ('step' step=INT)?;
	public RangeElements getRangeAccess() {
		return pRange;
	}
	
	public ParserRule getRangeRule() {
		return getRangeAccess().getRule();
	}
	
	////range of value of a constant
	//// CONSTRAINTS
	//// expressions defined in top down way starting from less precedence	
	//Constraint:
	//	'#' ImpliesExpression '#';
	public ConstraintElements getConstraintAccess() {
		return pConstraint;
	}
	
	public ParserRule getConstraintRule() {
		return getConstraintAccess().getRule();
	}
	
	//// precedence:
	//// not, and, or, implies
	//ImpliesExpression Expression:
	//	OrExpression ({ImpliesExpression.left=current} op=ImpliesOperator right=OrExpression)*;
	public ImpliesExpressionElements getImpliesExpressionAccess() {
		return pImpliesExpression;
	}
	
	public ParserRule getImpliesExpressionRule() {
		return getImpliesExpressionAccess().getRule();
	}
	
	//// 
	//OrExpression Expression:
	//	AndExpression ({OrExpression.left=current} OR_OPERATOR right=AndExpression)*;
	public OrExpressionElements getOrExpressionAccess() {
		return pOrExpression;
	}
	
	public ParserRule getOrExpressionRule() {
		return getOrExpressionAccess().getRule();
	}
	
	//AndExpression Expression:
	//	EqualExpression ({AndExpression.left=current} AND_OPERATOR right=EqualExpression)*;
	public AndExpressionElements getAndExpressionAccess() {
		return pAndExpression;
	}
	
	public ParserRule getAndExpressionRule() {
		return getAndExpressionAccess().getRule();
	}
	
	//EqualExpression Expression:
	//	RelationalExpression ({EqualExpression.left=current} op=EqualityOperators right=RelationalExpression)*;
	public EqualExpressionElements getEqualExpressionAccess() {
		return pEqualExpression;
	}
	
	public ParserRule getEqualExpressionRule() {
		return getEqualExpressionAccess().getRule();
	}
	
	//RelationalExpression Expression:
	//	PlusMinus ({RelationalExpression.left=current} op=RelationalOperators right=PlusMinus)*;
	public RelationalExpressionElements getRelationalExpressionAccess() {
		return pRelationalExpression;
	}
	
	public ParserRule getRelationalExpressionRule() {
		return getRelationalExpressionAccess().getRule();
	}
	
	//// a<b<c? 
	//// numerical expressions
	//PlusMinus Expression:
	//	ModMultDiv ({PlusMinus.left=current} op=PlusMinusOperators right=ModMultDiv)*;
	public PlusMinusElements getPlusMinusAccess() {
		return pPlusMinus;
	}
	
	public ParserRule getPlusMinusRule() {
		return getPlusMinusAccess().getRule();
	}
	
	//ModMultDiv Expression:
	//	Primary ({ModMultDiv.left=current} op=ModMultDivOperators right=Primary)*;
	public ModMultDivElements getModMultDivAccess() {
		return pModMultDiv;
	}
	
	public ParserRule getModMultDivRule() {
		return getModMultDivAccess().getRule();
	}
	
	//Primary Expression:
	//	NotExpression | '(' ImpliesExpression ')' | AtomicPredicate;
	public PrimaryElements getPrimaryAccess() {
		return pPrimary;
	}
	
	public ParserRule getPrimaryRule() {
		return getPrimaryAccess().getRule();
	}
	
	//NotExpression Expression:
	//	NOT_OPERATOR Primary {NotExpression.predicate=current};
	public NotExpressionElements getNotExpressionAccess() {
		return pNotExpression;
	}
	
	public ParserRule getNotExpressionRule() {
		return getNotExpressionAccess().getRule();
	}
	
	//// return an atomic predicate that cannot be further decomposed in predicates
	//AtomicPredicate:
	//	boolConst=BoolConst | name=elementID;
	public AtomicPredicateElements getAtomicPredicateAccess() {
		return pAtomicPredicate;
	}
	
	public ParserRule getAtomicPredicateRule() {
		return getAtomicPredicateAccess().getRule();
	}
	
	//enum RelationalOperators returns Operators:
	//	GT='>' | LT='<' | GE='>=' | LE='<=';
	public RelationalOperatorsElements getRelationalOperatorsAccess() {
		return eRelationalOperators;
	}
	
	public EnumRule getRelationalOperatorsRule() {
		return getRelationalOperatorsAccess().getRule();
	}
	
	//enum EqualityOperators returns Operators:
	//	EQ='==' | NE='!='
	//	| EQ='=';
	public EqualityOperatorsElements getEqualityOperatorsAccess() {
		return eEqualityOperators;
	}
	
	public EnumRule getEqualityOperatorsRule() {
		return getEqualityOperatorsAccess().getRule();
	}
	
	//// it gives a warning, but it works
	///*enum AndOperators:
	//	and='&&' | andmi='and' | ANDma='AND';
	//enum OrOperators:
	//	or='||' | ormi='or' | ORma='OR'; */ OR_OPERATOR:
	//	'||' | 'or' | 'OR' | '|';
	public OR_OPERATORElements getOR_OPERATORAccess() {
		return pOR_OPERATOR;
	}
	
	public ParserRule getOR_OPERATORRule() {
		return getOR_OPERATORAccess().getRule();
	}
	
	//AND_OPERATOR:
	//	'&&' | 'and' | 'AND' | '&';
	public AND_OPERATORElements getAND_OPERATORAccess() {
		return pAND_OPERATOR;
	}
	
	public ParserRule getAND_OPERATORRule() {
		return getAND_OPERATORAccess().getRule();
	}
	
	//NOT_OPERATOR:
	//	'!' | 'not';
	public NOT_OPERATORElements getNOT_OPERATORAccess() {
		return pNOT_OPERATOR;
	}
	
	public ParserRule getNOT_OPERATORRule() {
		return getNOT_OPERATORAccess().getRule();
	}
	
	//enum PlusMinusOperators:
	//	Plus='+' | Minus='-';
	public PlusMinusOperatorsElements getPlusMinusOperatorsAccess() {
		return ePlusMinusOperators;
	}
	
	public EnumRule getPlusMinusOperatorsRule() {
		return getPlusMinusOperatorsAccess().getRule();
	}
	
	//enum ModMultDivOperators:
	//	Mod='%' | Mult='*' | Div='/';
	public ModMultDivOperatorsElements getModMultDivOperatorsAccess() {
		return eModMultDivOperators;
	}
	
	public EnumRule getModMultDivOperatorsRule() {
		return getModMultDivOperatorsAccess().getRule();
	}
	
	//enum ImpliesOperator:
	//	Impl='=>' | Iff='<=>' |
	//	Impl='->' | Iff='<->';
	public ImpliesOperatorElements getImpliesOperatorAccess() {
		return eImpliesOperator;
	}
	
	public EnumRule getImpliesOperatorRule() {
		return getImpliesOperatorAccess().getRule();
	}
	
	//// it gives a warning, but it works
	//BoolConst:
	//	'false' | 'true' | 'FALSE' | 'TRUE';
	public BoolConstElements getBoolConstAccess() {
		return pBoolConst;
	}
	
	public ParserRule getBoolConstRule() {
		return getBoolConstAccess().getRule();
	}
	
	//elementID:
	//	ID | NUMID | STRING | '-'? INT;
	public ElementIDElements getElementIDAccess() {
		return pElementID;
	}
	
	public ParserRule getElementIDRule() {
		return getElementIDAccess().getRule();
	}
	
	//terminal NUMID:
	//	'0'..'9'+ ID;
	public TerminalRule getNUMIDRule() {
		return tNUMID;
	}
	
	//PossiblySignedNumber EIntegerObject:
	//	'-'? INT;
	public PossiblySignedNumberElements getPossiblySignedNumberAccess() {
		return pPossiblySignedNumber;
	}
	
	public ParserRule getPossiblySignedNumberRule() {
		return getPossiblySignedNumberAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' | "'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
