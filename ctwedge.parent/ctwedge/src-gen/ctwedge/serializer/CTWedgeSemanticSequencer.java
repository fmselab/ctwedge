/*
 * generated by Xtext 2.15.0
 */
package ctwedge.serializer;

import com.google.inject.Inject;
import ctwedge.ctWedge.AndExpression;
import ctwedge.ctWedge.AtomicPredicate;
import ctwedge.ctWedge.Bool;
import ctwedge.ctWedge.CitModel;
import ctwedge.ctWedge.CtWedgePackage;
import ctwedge.ctWedge.Element;
import ctwedge.ctWedge.Enumerative;
import ctwedge.ctWedge.EqualExpression;
import ctwedge.ctWedge.ImpliesExpression;
import ctwedge.ctWedge.ModMultDiv;
import ctwedge.ctWedge.NotExpression;
import ctwedge.ctWedge.OrExpression;
import ctwedge.ctWedge.PlusMinus;
import ctwedge.ctWedge.Range;
import ctwedge.ctWedge.RelationalExpression;
import ctwedge.services.CTWedgeGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class CTWedgeSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CTWedgeGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CtWedgePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CtWedgePackage.AND_EXPRESSION:
				sequence_AndExpression(context, (AndExpression) semanticObject); 
				return; 
			case CtWedgePackage.ATOMIC_PREDICATE:
				sequence_AtomicPredicate(context, (AtomicPredicate) semanticObject); 
				return; 
			case CtWedgePackage.BOOL:
				sequence_Bool(context, (Bool) semanticObject); 
				return; 
			case CtWedgePackage.CIT_MODEL:
				sequence_CitModel(context, (CitModel) semanticObject); 
				return; 
			case CtWedgePackage.ELEMENT:
				sequence_Element(context, (Element) semanticObject); 
				return; 
			case CtWedgePackage.ENUMERATIVE:
				sequence_Enumerative(context, (Enumerative) semanticObject); 
				return; 
			case CtWedgePackage.EQUAL_EXPRESSION:
				sequence_EqualExpression(context, (EqualExpression) semanticObject); 
				return; 
			case CtWedgePackage.IMPLIES_EXPRESSION:
				sequence_ImpliesExpression(context, (ImpliesExpression) semanticObject); 
				return; 
			case CtWedgePackage.MOD_MULT_DIV:
				sequence_ModMultDiv(context, (ModMultDiv) semanticObject); 
				return; 
			case CtWedgePackage.NOT_EXPRESSION:
				sequence_NotExpression(context, (NotExpression) semanticObject); 
				return; 
			case CtWedgePackage.OR_EXPRESSION:
				sequence_OrExpression(context, (OrExpression) semanticObject); 
				return; 
			case CtWedgePackage.PLUS_MINUS:
				sequence_PlusMinus(context, (PlusMinus) semanticObject); 
				return; 
			case CtWedgePackage.RANGE:
				sequence_Range(context, (Range) semanticObject); 
				return; 
			case CtWedgePackage.RELATIONAL_EXPRESSION:
				sequence_RelationalExpression(context, (RelationalExpression) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Constraint returns AndExpression
	 *     ImpliesExpression returns AndExpression
	 *     ImpliesExpression.ImpliesExpression_1_0 returns AndExpression
	 *     OrExpression returns AndExpression
	 *     OrExpression.OrExpression_1_0 returns AndExpression
	 *     AndExpression returns AndExpression
	 *     AndExpression.AndExpression_1_0 returns AndExpression
	 *     EqualExpression returns AndExpression
	 *     EqualExpression.EqualExpression_1_0 returns AndExpression
	 *     RelationalExpression returns AndExpression
	 *     RelationalExpression.RelationalExpression_1_0 returns AndExpression
	 *     PlusMinus returns AndExpression
	 *     PlusMinus.PlusMinus_1_0 returns AndExpression
	 *     ModMultDiv returns AndExpression
	 *     ModMultDiv.ModMultDiv_1_0 returns AndExpression
	 *     Primary returns AndExpression
	 *     NotExpression.NotExpression_2 returns AndExpression
	 *
	 * Constraint:
	 *     (left=AndExpression_AndExpression_1_0 right=EqualExpression)
	 */
	protected void sequence_AndExpression(ISerializationContext context, AndExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CtWedgePackage.Literals.AND_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CtWedgePackage.Literals.AND_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, CtWedgePackage.Literals.AND_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CtWedgePackage.Literals.AND_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndExpressionAccess().getRightEqualExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns AtomicPredicate
	 *     ImpliesExpression returns AtomicPredicate
	 *     ImpliesExpression.ImpliesExpression_1_0 returns AtomicPredicate
	 *     OrExpression returns AtomicPredicate
	 *     OrExpression.OrExpression_1_0 returns AtomicPredicate
	 *     AndExpression returns AtomicPredicate
	 *     AndExpression.AndExpression_1_0 returns AtomicPredicate
	 *     EqualExpression returns AtomicPredicate
	 *     EqualExpression.EqualExpression_1_0 returns AtomicPredicate
	 *     RelationalExpression returns AtomicPredicate
	 *     RelationalExpression.RelationalExpression_1_0 returns AtomicPredicate
	 *     PlusMinus returns AtomicPredicate
	 *     PlusMinus.PlusMinus_1_0 returns AtomicPredicate
	 *     ModMultDiv returns AtomicPredicate
	 *     ModMultDiv.ModMultDiv_1_0 returns AtomicPredicate
	 *     Primary returns AtomicPredicate
	 *     NotExpression.NotExpression_2 returns AtomicPredicate
	 *     AtomicPredicate returns AtomicPredicate
	 *
	 * Constraint:
	 *     (boolConst=BoolConst | name=elementID)
	 */
	protected void sequence_AtomicPredicate(ISerializationContext context, AtomicPredicate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Bool
	 *     Bool returns Bool
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Bool(ISerializationContext context, Bool semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CtWedgePackage.Literals.PARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CtWedgePackage.Literals.PARAMETER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBoolAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CitModel returns CitModel
	 *
	 * Constraint:
	 *     (name=ID parameters+=Parameter+ constraints+=Constraint*)
	 */
	protected void sequence_CitModel(ISerializationContext context, CitModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns Element
	 *
	 * Constraint:
	 *     name=elementID
	 */
	protected void sequence_Element(ISerializationContext context, Element semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CtWedgePackage.Literals.ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CtWedgePackage.Literals.ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElementAccess().getNameElementIDParserRuleCall_0_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Enumerative
	 *     Enumerative returns Enumerative
	 *
	 * Constraint:
	 *     (name=ID elements+=Element+)
	 */
	protected void sequence_Enumerative(ISerializationContext context, Enumerative semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns EqualExpression
	 *     ImpliesExpression returns EqualExpression
	 *     ImpliesExpression.ImpliesExpression_1_0 returns EqualExpression
	 *     OrExpression returns EqualExpression
	 *     OrExpression.OrExpression_1_0 returns EqualExpression
	 *     AndExpression returns EqualExpression
	 *     AndExpression.AndExpression_1_0 returns EqualExpression
	 *     EqualExpression returns EqualExpression
	 *     EqualExpression.EqualExpression_1_0 returns EqualExpression
	 *     RelationalExpression returns EqualExpression
	 *     RelationalExpression.RelationalExpression_1_0 returns EqualExpression
	 *     PlusMinus returns EqualExpression
	 *     PlusMinus.PlusMinus_1_0 returns EqualExpression
	 *     ModMultDiv returns EqualExpression
	 *     ModMultDiv.ModMultDiv_1_0 returns EqualExpression
	 *     Primary returns EqualExpression
	 *     NotExpression.NotExpression_2 returns EqualExpression
	 *
	 * Constraint:
	 *     (left=EqualExpression_EqualExpression_1_0 op=EqualityOperators right=RelationalExpression)
	 */
	protected void sequence_EqualExpression(ISerializationContext context, EqualExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CtWedgePackage.Literals.EQUAL_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CtWedgePackage.Literals.EQUAL_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, CtWedgePackage.Literals.EQUAL_EXPRESSION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CtWedgePackage.Literals.EQUAL_EXPRESSION__OP));
			if (transientValues.isValueTransient(semanticObject, CtWedgePackage.Literals.EQUAL_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CtWedgePackage.Literals.EQUAL_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualExpressionAccess().getEqualExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEqualExpressionAccess().getOpEqualityOperatorsEnumRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getEqualExpressionAccess().getRightRelationalExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns ImpliesExpression
	 *     ImpliesExpression returns ImpliesExpression
	 *     ImpliesExpression.ImpliesExpression_1_0 returns ImpliesExpression
	 *     OrExpression returns ImpliesExpression
	 *     OrExpression.OrExpression_1_0 returns ImpliesExpression
	 *     AndExpression returns ImpliesExpression
	 *     AndExpression.AndExpression_1_0 returns ImpliesExpression
	 *     EqualExpression returns ImpliesExpression
	 *     EqualExpression.EqualExpression_1_0 returns ImpliesExpression
	 *     RelationalExpression returns ImpliesExpression
	 *     RelationalExpression.RelationalExpression_1_0 returns ImpliesExpression
	 *     PlusMinus returns ImpliesExpression
	 *     PlusMinus.PlusMinus_1_0 returns ImpliesExpression
	 *     ModMultDiv returns ImpliesExpression
	 *     ModMultDiv.ModMultDiv_1_0 returns ImpliesExpression
	 *     Primary returns ImpliesExpression
	 *     NotExpression.NotExpression_2 returns ImpliesExpression
	 *
	 * Constraint:
	 *     (left=ImpliesExpression_ImpliesExpression_1_0 op=ImpliesOperator right=OrExpression)
	 */
	protected void sequence_ImpliesExpression(ISerializationContext context, ImpliesExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CtWedgePackage.Literals.IMPLIES_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CtWedgePackage.Literals.IMPLIES_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, CtWedgePackage.Literals.IMPLIES_EXPRESSION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CtWedgePackage.Literals.IMPLIES_EXPRESSION__OP));
			if (transientValues.isValueTransient(semanticObject, CtWedgePackage.Literals.IMPLIES_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CtWedgePackage.Literals.IMPLIES_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImpliesExpressionAccess().getImpliesExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getImpliesExpressionAccess().getOpImpliesOperatorEnumRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getImpliesExpressionAccess().getRightOrExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns ModMultDiv
	 *     ImpliesExpression returns ModMultDiv
	 *     ImpliesExpression.ImpliesExpression_1_0 returns ModMultDiv
	 *     OrExpression returns ModMultDiv
	 *     OrExpression.OrExpression_1_0 returns ModMultDiv
	 *     AndExpression returns ModMultDiv
	 *     AndExpression.AndExpression_1_0 returns ModMultDiv
	 *     EqualExpression returns ModMultDiv
	 *     EqualExpression.EqualExpression_1_0 returns ModMultDiv
	 *     RelationalExpression returns ModMultDiv
	 *     RelationalExpression.RelationalExpression_1_0 returns ModMultDiv
	 *     PlusMinus returns ModMultDiv
	 *     PlusMinus.PlusMinus_1_0 returns ModMultDiv
	 *     ModMultDiv returns ModMultDiv
	 *     ModMultDiv.ModMultDiv_1_0 returns ModMultDiv
	 *     Primary returns ModMultDiv
	 *     NotExpression.NotExpression_2 returns ModMultDiv
	 *
	 * Constraint:
	 *     (left=ModMultDiv_ModMultDiv_1_0 op=ModMultDivOperators right=Primary)
	 */
	protected void sequence_ModMultDiv(ISerializationContext context, ModMultDiv semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CtWedgePackage.Literals.MOD_MULT_DIV__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CtWedgePackage.Literals.MOD_MULT_DIV__LEFT));
			if (transientValues.isValueTransient(semanticObject, CtWedgePackage.Literals.MOD_MULT_DIV__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CtWedgePackage.Literals.MOD_MULT_DIV__OP));
			if (transientValues.isValueTransient(semanticObject, CtWedgePackage.Literals.MOD_MULT_DIV__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CtWedgePackage.Literals.MOD_MULT_DIV__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModMultDivAccess().getModMultDivLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getModMultDivAccess().getOpModMultDivOperatorsEnumRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getModMultDivAccess().getRightPrimaryParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns NotExpression
	 *     ImpliesExpression returns NotExpression
	 *     ImpliesExpression.ImpliesExpression_1_0 returns NotExpression
	 *     OrExpression returns NotExpression
	 *     OrExpression.OrExpression_1_0 returns NotExpression
	 *     AndExpression returns NotExpression
	 *     AndExpression.AndExpression_1_0 returns NotExpression
	 *     EqualExpression returns NotExpression
	 *     EqualExpression.EqualExpression_1_0 returns NotExpression
	 *     RelationalExpression returns NotExpression
	 *     RelationalExpression.RelationalExpression_1_0 returns NotExpression
	 *     PlusMinus returns NotExpression
	 *     PlusMinus.PlusMinus_1_0 returns NotExpression
	 *     ModMultDiv returns NotExpression
	 *     ModMultDiv.ModMultDiv_1_0 returns NotExpression
	 *     Primary returns NotExpression
	 *     NotExpression returns NotExpression
	 *     NotExpression.NotExpression_2 returns NotExpression
	 *
	 * Constraint:
	 *     predicate=NotExpression_NotExpression_2
	 */
	protected void sequence_NotExpression(ISerializationContext context, NotExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CtWedgePackage.Literals.NOT_EXPRESSION__PREDICATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CtWedgePackage.Literals.NOT_EXPRESSION__PREDICATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotExpressionAccess().getNotExpressionPredicateAction_2(), semanticObject.getPredicate());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns OrExpression
	 *     ImpliesExpression returns OrExpression
	 *     ImpliesExpression.ImpliesExpression_1_0 returns OrExpression
	 *     OrExpression returns OrExpression
	 *     OrExpression.OrExpression_1_0 returns OrExpression
	 *     AndExpression returns OrExpression
	 *     AndExpression.AndExpression_1_0 returns OrExpression
	 *     EqualExpression returns OrExpression
	 *     EqualExpression.EqualExpression_1_0 returns OrExpression
	 *     RelationalExpression returns OrExpression
	 *     RelationalExpression.RelationalExpression_1_0 returns OrExpression
	 *     PlusMinus returns OrExpression
	 *     PlusMinus.PlusMinus_1_0 returns OrExpression
	 *     ModMultDiv returns OrExpression
	 *     ModMultDiv.ModMultDiv_1_0 returns OrExpression
	 *     Primary returns OrExpression
	 *     NotExpression.NotExpression_2 returns OrExpression
	 *
	 * Constraint:
	 *     (left=OrExpression_OrExpression_1_0 right=AndExpression)
	 */
	protected void sequence_OrExpression(ISerializationContext context, OrExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CtWedgePackage.Literals.OR_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CtWedgePackage.Literals.OR_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, CtWedgePackage.Literals.OR_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CtWedgePackage.Literals.OR_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrExpressionAccess().getRightAndExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns PlusMinus
	 *     ImpliesExpression returns PlusMinus
	 *     ImpliesExpression.ImpliesExpression_1_0 returns PlusMinus
	 *     OrExpression returns PlusMinus
	 *     OrExpression.OrExpression_1_0 returns PlusMinus
	 *     AndExpression returns PlusMinus
	 *     AndExpression.AndExpression_1_0 returns PlusMinus
	 *     EqualExpression returns PlusMinus
	 *     EqualExpression.EqualExpression_1_0 returns PlusMinus
	 *     RelationalExpression returns PlusMinus
	 *     RelationalExpression.RelationalExpression_1_0 returns PlusMinus
	 *     PlusMinus returns PlusMinus
	 *     PlusMinus.PlusMinus_1_0 returns PlusMinus
	 *     ModMultDiv returns PlusMinus
	 *     ModMultDiv.ModMultDiv_1_0 returns PlusMinus
	 *     Primary returns PlusMinus
	 *     NotExpression.NotExpression_2 returns PlusMinus
	 *
	 * Constraint:
	 *     (left=PlusMinus_PlusMinus_1_0 op=PlusMinusOperators right=ModMultDiv)
	 */
	protected void sequence_PlusMinus(ISerializationContext context, PlusMinus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CtWedgePackage.Literals.PLUS_MINUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CtWedgePackage.Literals.PLUS_MINUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, CtWedgePackage.Literals.PLUS_MINUS__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CtWedgePackage.Literals.PLUS_MINUS__OP));
			if (transientValues.isValueTransient(semanticObject, CtWedgePackage.Literals.PLUS_MINUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CtWedgePackage.Literals.PLUS_MINUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusMinusAccess().getPlusMinusLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusMinusAccess().getOpPlusMinusOperatorsEnumRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getPlusMinusAccess().getRightModMultDivParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Range
	 *     Range returns Range
	 *
	 * Constraint:
	 *     (name=ID begin=PossiblySignedNumber end=PossiblySignedNumber step=INT?)
	 */
	protected void sequence_Range(ISerializationContext context, Range semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns RelationalExpression
	 *     ImpliesExpression returns RelationalExpression
	 *     ImpliesExpression.ImpliesExpression_1_0 returns RelationalExpression
	 *     OrExpression returns RelationalExpression
	 *     OrExpression.OrExpression_1_0 returns RelationalExpression
	 *     AndExpression returns RelationalExpression
	 *     AndExpression.AndExpression_1_0 returns RelationalExpression
	 *     EqualExpression returns RelationalExpression
	 *     EqualExpression.EqualExpression_1_0 returns RelationalExpression
	 *     RelationalExpression returns RelationalExpression
	 *     RelationalExpression.RelationalExpression_1_0 returns RelationalExpression
	 *     PlusMinus returns RelationalExpression
	 *     PlusMinus.PlusMinus_1_0 returns RelationalExpression
	 *     ModMultDiv returns RelationalExpression
	 *     ModMultDiv.ModMultDiv_1_0 returns RelationalExpression
	 *     Primary returns RelationalExpression
	 *     NotExpression.NotExpression_2 returns RelationalExpression
	 *
	 * Constraint:
	 *     (left=RelationalExpression_RelationalExpression_1_0 op=RelationalOperators right=PlusMinus)
	 */
	protected void sequence_RelationalExpression(ISerializationContext context, RelationalExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CtWedgePackage.Literals.RELATIONAL_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CtWedgePackage.Literals.RELATIONAL_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, CtWedgePackage.Literals.RELATIONAL_EXPRESSION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CtWedgePackage.Literals.RELATIONAL_EXPRESSION__OP));
			if (transientValues.isValueTransient(semanticObject, CtWedgePackage.Literals.RELATIONAL_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CtWedgePackage.Literals.RELATIONAL_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationalExpressionAccess().getRelationalExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getRelationalExpressionAccess().getOpRelationalOperatorsEnumRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getRelationalExpressionAccess().getRightPlusMinusParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
}
